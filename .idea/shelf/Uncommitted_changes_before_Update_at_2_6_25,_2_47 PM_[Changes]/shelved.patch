Index: call_Classifier_sessionlevel_Feb062025.sh
===================================================================
diff --git a/call_Classifier_sessionlevel_Feb062025.sh b/call_Classifier_sessionlevel_Feb062025.sh
deleted file mode 100644
--- a/call_Classifier_sessionlevel_Feb062025.sh	(revision a48ad6d7b871883193dcc53c21bc0954398851dc)
+++ /dev/null	(revision a48ad6d7b871883193dcc53c21bc0954398851dc)
@@ -1,95 +0,0 @@
-#!/usr/bin/env bash
-# mkdir /input
-# mkdir /working
-export XNAT_USER=${2}
-export XNAT_PASS=${3}
-export XNAT_HOST=${4} #"https://snipr-dev-test1.nrg.wustl.edu"
-sessionId=$1          #SNIPR_E03539 #SNIPR_E03526
-
-echo call_Classifier_sessionlevel.sh $*
-echo XNAT_USER $XNAT_USER
-echo XNAT_PASS $XNAT_PASS
-echo XNAT_HOST $XNAT_HOST
-echo sessionId $sessionId
-echo ""
-
-
-function wait_for_file() {
-  local file_to_wait=${1} #${filename}
-  local sleep_second=1
-  local sleep_second_counter=0
-  while [ ! -e ${file_to_wait} ]; do
-    sleep ${sleep_second}
-    sleep_second_counter=$((sleep_second_counter + 1))
-    if [ ${sleep_second_counter} -gt 10 ]; then
-      echo sleep_second_counter::${sleep_second_counter} >>/output/error.txt
-      break
-    fi
-    echo sleep_second_counter::${sleep_second_counter} >>/output/error.txt
-  done
-
-}
-#file_to_wait=$1
-#while [ ! –e ${file_to_wait} ]
-#do
-#  sleep 1
-#done
-#
-#echo “${file_to_wait} has been created”
- scanID=$2 #8
- rm -r /ZIPFILEDIR/*
-# cp /mounted_directory/Classifier_wholeSession.py /run/Classifier_wholeSession.py
- cd /run/
- echo $PWD
-echo python /software1/Classifier_session_level.py /input /working ${sessionId}  #${scanID}
-python /software1/Classifier_session_level.py /input /working ${sessionId}  #${scanID}
-
-#output_directory=/output/
-#filename=${output_directory}/${sessionId}.csv
-#call_get_metadata_session_saveascsv_arguments=('call_get_metadata_session_saveascsv' ${sessionId} ${filename})
-#outputfiles_present=$(python /software1/Classifier_session_level_v1_5July2023.py "${call_get_metadata_session_saveascsv_arguments[@]}")
-#wait_for_file ${filename}
-#echo outputfiles_present::${outputfiles_present} >>/output/error.txt
-##while IFS=',' read -ra array; do
-#  ################################################
-#  sessionDir=/DICOMFILEDIR
-#  workingDir=/input      # args.stuff[2]
-#  sessionId=${sessionId} # args.stuff[3]
-#  call_classifier_v1_arguments=('call_classifier_v1' ${sessionId} ${workingDir} ${sessionId})
-#  outputfiles_present=$(python /software1/Classifier_session_level_v1_5July2023.py "${call_classifier_v1_arguments[@]}")
-#  echo outputfiles_present::${outputfiles_present}
-#  ################################################
-#  #
-#  #  URI=${array[6]}
-#  #  #  echo "URI":${URI}
-#  #  resource_dir="DICOM"
-#  #  output_csvfile=${sessionId}_SCANSCANTEMP_${array[4]}.csv
-#  #  #  echo "output_csvfile":${output_csvfile}
-#  #  dir_to_receive_the_data=${output_directory}
-#  #  call_get_resourcefiles_metadata_saveascsv_args_arguments=('call_get_resourcefiles_metadata_saveascsv_args' ${URI} ${resource_dir} ${dir_to_receive_the_data} ${output_csvfile})
-#  #  outputfiles_present=$(python /software1/Classifier_session_level_v1_5July2023.py "${call_get_resourcefiles_metadata_saveascsv_args_arguments[@]}")
-#  #  wait_for_file ${dir_to_receive_the_data}/${output_csvfile}
-#  #  SCAN_ID=${array[4]}
-#  #
-#  #  if [ ${SCAN_ID} == "2" ]; then
-#  #    call_sort_dicom_list_arguments=('call_sort_dicom_list' ${dir_to_receive_the_data}/${output_csvfile})
-#  #    outputfiles_present=$(python /software1/Classifier_session_level_v1_5July2023.py "${call_sort_dicom_list_arguments[@]}")
-#  #    echo "SCAN_ID::${SCAN_ID}"
-#  #    while IFS=',' read -ra array1; do
-#  #      url=${array1[6]}
-#  #      #    echo url::${url}
-#  #      dicom_filename=${array1[8]}
-#  #      #    echo dicom_filename::${dicom_filename}
-#  #      #    filename=args.stuff[2]
-#  #
-#  #      dir_to_save=/DICOMFILEDIR ##args.stuff[3]
-#  #      call_download_a_singlefile_with_URIString_arguments=('call_download_a_singlefile_with_URIString' ${url} ${dicom_filename} ${dir_to_save})
-#  ##      outputfiles_present=$(python /software1/Classifier_session_level_v1_5July2023.py "${call_download_a_singlefile_with_URIString_arguments[@]}")
-#  #
-#  #
-#  #
-#  #    done < <(tail -n +2 "${dir_to_receive_the_data}/${output_csvfile}")
-#  #
-#  #    break
-#  #  fi
-##done < <(tail -n +2 "${filename}")
Index: Classifier_session_levelFeb062025.py
===================================================================
diff --git a/Classifier_session_levelFeb062025.py b/Classifier_session_levelFeb062025.py
deleted file mode 100644
--- a/Classifier_session_levelFeb062025.py	(revision a48ad6d7b871883193dcc53c21bc0954398851dc)
+++ /dev/null	(revision a48ad6d7b871883193dcc53c21bc0954398851dc)
@@ -1,220 +0,0 @@
-#!/usr/bin/python
-
-import os, sys, errno, shutil, uuid
-import math
-import glob
-import re
-import requests
-import pydicom as dicom
-import subprocess
-from xnatSession import XnatSession
-import DecompressDCM
-import label_probability
-from updatemysql import insert_data, update_or_create_column
-# Prep XNAT session
-XNAT_HOST = 'https://snipr.wustl.edu' #os.environ['XNAT_HOST']#
-XNAT_USER = os.environ['XNAT_USER']
-XNAT_PASS = os.environ['XNAT_PASS']
-catalogXmlRegex = re.compile(r'.*\.xml$')
-
-def get_slice_idx(nDicomFiles):
-    return min(nDicomFiles-1, math.ceil(nDicomFiles*0.7)) # slice 70% through the brain
-def get_metadata_session(sessionId):
-    url = ("/data/experiments/%s/scans/?format=json" %    (sessionId))
-    xnatSession = XnatSession(username=XNAT_USER, password=XNAT_PASS, host=XNAT_HOST)
-    xnatSession.renew_httpsession()
-    response = xnatSession.httpsess.get(xnatSession.host + url)
-    xnatSession.close_httpsession()
-    metadata_session=response.json()['ResultSet']['Result']
-    return metadata_session
-
-def get_dicom_from_filesystem(sessionId, scanId,xnatSession):
-    # Handle DICOM files that are not stored in a directory matching their XNAT scanId
-    print("No DICOM found in %s directory, querying XNAT for DICOM path" % scanId)
-    url = ("/data/experiments/%s/scans/%s/files?format=json&locator=absolutePath&file_format=DICOM" %
-           (sessionId, scanId))
-    xnatSession.renew_httpsession()
-    response = xnatSession.httpsess.get(xnatSession.host + url)
-    if response.status_code != 200:
-        raise Exception("Error querying XNAT for %s DICOM files: %s %s %s" % (scanId,
-                                                                              response.status_code,
-                                                                              response.reason,
-                                                                              response.text))
-    result = response.json()['ResultSet']['Result']
-    # print(result[0]) #['absolutePath'])
-    nDicomFiles = len(result)
-    # print(nDicomFiles)
-    if nDicomFiles == 0:
-        raise Exception("No DICOM files for %s stored in XNAT" % scanId)
-
-    # Get 70% file and ensure it exists
-    selDicomAbs = result[get_slice_idx(nDicomFiles)]['absolutePath']
-    ###########################################################################
-    scanDir='/input'
-    # if not os.path.isdir(scanDir):
-    #     continue
-    for dcm in glob.iglob(os.path.join(scanDir, "**"), recursive=True):
-        try:
-            # Test if it's a DICOM file
-            dicomDs = dicom.filereader.dcmread(dcm)
-            # Gather all in series and return the slice 70% thru brain
-            dicomFiles = [fl for fl in glob.iglob(os.path.join(os.path.dirname(dcm), "*")) if not catalogXmlRegex.match(fl)]
-            nDicomFiles = len(dicomFiles)
-            selDicom = dicomFiles[get_slice_idx(nDicomFiles)]
-            print("Found %s DICOM files, using %s for snapshot" % (nDicomFiles, selDicom))
-            return selDicom, nDicomFiles
-        except (dicom.errors.InvalidDicomError, IsADirectoryError):
-            # Skip, not a dicom
-            pass
-    raise Exception("No DICOM files found for %s" % scanId)
-
-def get_dicom_using_xnat(sessionId, scanId,xnatSession):
-    # xnatSession = XnatSession(username=XNAT_USER, password=XNAT_PASS, host=XNAT_HOST)
-    url = ("/data/experiments/%s/scans/%s/files?format=json&locator=absolutePath&file_format=DICOM" %
-           (sessionId,scanId ))
-    print(url)
-    xnatSession.renew_httpsession()
-    response = xnatSession.httpsess.get(xnatSession.host + url)
-
-    result = response.json()['ResultSet']['Result']
-    nDicomFiles = len(result)
-    if nDicomFiles == 0:
-        raise Exception("No DICOM files for %s stored in XNAT" % scanId)
-
-    #     # Get 70% file and ensure it exists
-    selDicomAbs = result[get_slice_idx(nDicomFiles)]['absolutePath']
-    print(selDicomAbs)
-    #     # selDicomAbs_split=selDicomAbs.split('/')
-    #     # print(selDicomAbs_split[-5]+'_'+selDicomAbs_split[-3])
-    #     ######################################################################################
-
-    #     # print("No DICOM found in %s directory, querying XNAT for DICOM path" % scanId)
-    url = ("/data/experiments/%s/scans/%s/resources/DICOM/files?format=zip" %
-           (sessionId, scanId))
-    print(url)
-
-    xnatSession.renew_httpsession()
-    response = xnatSession.httpsess.get(xnatSession.host + url)
-    zipfilename=sessionId+scanId+'.zip'
-    #############################
-    print(zipfilename)
-    print('/ZIPFILEDIR')
-    subprocess.run("pwd",shell=True, capture_output=True)
-    subprocess.run("ls -la",shell=True, capture_output=True)
-    subprocess.run("whoami",shell=True, capture_output=True)
-    subprocess.run('ls -la /ZIPFILEDIR',shell=True, capture_output=True)
-    ###############################
-    with open(zipfilename, "wb") as f:
-        print("Zip file opened")
-        for chunk in response.iter_content(chunk_size=512):
-            if chunk:  # filter out keep-alive new chunks
-                f.write(chunk)
-    ############################
-    print("Zip file stored")
-    subprocess.run("ls -la",shell=True, capture_output=True)
-    #####################
-    command = 'unzip -d /ZIPFILEDIR ' + zipfilename
-    subprocess.run(command,shell=True, capture_output=True)
-    #########################
-    print("Unzip -d complete")
-    command = 'find /ZIPFILEDIR -type f'
-    subprocess.run(command,shell=True, capture_output=True)
-    ######################
-
-    command = 'cp  /ZIPFILEDIR/*/*/*/*/*/*/*.dcm  /DICOMFILEDIR/ '
-    subprocess.run(command,shell=True, capture_output=True)
-    subprocess.run('ls -l /DICOMFILEDIR',shell=True, capture_output=True)
-    #     #################################################################
-    sessionDir='/DICOMFILEDIR'
-
-    selDicomAbs = result[get_slice_idx(nDicomFiles)]['absolutePath']
-    # #/ZIPFILEDIR/BJH_011_13102019_0715/*/*/*/*/**
-    selDicom=os.path.join(sessionDir,os.path.basename(selDicomAbs))
-    print(selDicom)
-    return selDicom, nDicomFiles
-
-
-def run_classifier(sessionDir, rawDir, jpgDir, sessionId, scanId, xnatSession):
-    # def run_classifier(sessionDir, rawDir, jpgDir, sessionId, scanId, xnatSesDir, xnatSession):
-    print("Classifying scan %s" % scanId)
-    # Select DICOM file for scanId (70% thru the brain)
-    selDicom, nDicomFiles = get_dicom_using_xnat(sessionId, scanId,xnatSession) #, sessionDir, xnatSesDir, xnatSession)
-    # selDicom, nDicomFiles = get_dicom_from_filesystem(sessionId, scanId,xnatSession)
-    print(selDicom)
-    print(nDicomFiles)
-    ####################################################################
-    selDicomDecompr = os.path.join(rawDir, os.path.basename(selDicom))
-    DecompressDCM.decompress(selDicom, selDicomDecompr)
-    # Classify it
-    label = label_probability.classify(selDicomDecompr, jpgDir, scanId, nDicomFiles)
-    print("Scan classification for %s scan %s is '%s'" % (sessionId, scanId, label))
-    # Change value of series_class in XNAT
-    # url = ("/data/experiments/%s/scans/%s?xsiType=xnat:mrScanData&xnat:imageScanData/series_class=%s" %
-    #     (sessionId, scanId, label))
-    url = ("/data/experiments/%s/scans/%s?xsiType=xnat:ctScanData&type=%s" % (sessionId, scanId, label))
-    # xnatSession.renew_httpsession()
-    response = xnatSession.httpsess.put(xnatSession.host + url)
-    if response.status_code == 200 or response.status_code == 201:
-        print("Successfully set type for %s scan %s to '%s'" % (sessionId, scanId, label))
-        session_name=session_id=sessionId
-        scan_name=scan_id=scanId
-        insert_data(session_id, session_name, scan_id, scan_name)
-        column_name='test_insert'
-        column_value='Yes'
-        update_or_create_column(session_id, scan_id, column_name, column_value,session_name,scan_name)
-    else:
-        errStr = "ERROR"
-        if response.status_code == 403 or response.status_code == 404:
-            errStr = "PERMISSION DENIED"
-        raise Exception("%s attempting to set type for %s %s to '%s': %s" %
-                        (errStr, sessionId, scanId, label, response.text))
-
-
-if __name__ == '__main__':
-
-    sessionDir = sys.argv[1]
-    workingDir = sys.argv[2]
-    sessionId = sys.argv[3]
-    print ("Classifier_session_level.py sessionDir: {} workingDir: {} sessionId: {}".format (sessionDir, workingDir,sessionId))
-    print ("XNAT_HOST: {} XNAT_USER: {} XNAT_PASS: {}".format(XNAT_HOST, XNAT_USER, XNAT_PASS))
-    # print ("Classifier_session_level.py sessionDir: %, workingDir: %, sessionId: %" % (sessionDir, workingDir,sessionId))
-    # print ("XNAT_HOST: %, XNAT_USER: %, XNAT_PASS: %" (XNAT_HOST, XNAT_USER, XNAT_PASS))
-    ##############################################
-    metadata_session=get_metadata_session(sessionId)
-    for x in metadata_session:
-        # if int(x['ID']) == scanId:
-        scanId=x['ID']
-
-
-        try:
-
-            ###########################################################
-            # xnatSesDir = sys.argv[4]
-            # scans = [sys.argv[4]] #sys.argv[5].split()
-            # scanId=scans[0]
-            # Make working dirs
-            rawDir = os.path.join(workingDir, 'RAW')
-            os.makedirs(rawDir, exist_ok = True)
-            jpgDir = os.path.join(workingDir, 'JPG' )
-            os.makedirs(jpgDir, exist_ok = True)
-            command="rm -r  " + rawDir + "/*"
-            subprocess.call(command,shell=True)
-            command="rm -r  " + jpgDir + "/*"
-            subprocess.call(command,shell=True)
-            command="rm -r /NIFTIFILEDIR/*"
-            subprocess.call(command,shell=True)
-            # for x in range(1,5):
-            #     print(sys.argv[x])
-            command="rm -r /ZIPFILEDIR/*"
-            subprocess.call(command,shell=True)
-            command="rm -r /DICOMFILEDIR/*"
-            subprocess.call(command,shell=True)
-            # for x in range(10):
-            #     print("{}:XNAT_HOST".format(XNAT_HOST))
-            xnatSession = XnatSession(username=XNAT_USER, password=XNAT_PASS, host=XNAT_HOST)
-            run_classifier(sessionDir, rawDir, jpgDir, sessionId, scanId, xnatSession)
-            # Handle DICOM files that are not stored in a directory matching their XNAT scanId
-            xnatSession.close_httpsession()
-        except Exception as e: # work on python 3.x
-            print('Exception occured: '+ str(e))
-            continue
\ No newline at end of file
Index: updatemysql.py
===================================================================
diff --git a/updatemysql.py b/updatemysql.py
deleted file mode 100644
--- a/updatemysql.py	(revision a48ad6d7b871883193dcc53c21bc0954398851dc)
+++ /dev/null	(revision a48ad6d7b871883193dcc53c21bc0954398851dc)
@@ -1,154 +0,0 @@
-import mysql.connector
-import random,sys
-# Database connection setup
-# def connect_to_database():
-#     return mysql.connector.connect(
-#         host="localhost",  # Replace with your database host
-#         user="root",  # Replace with your username
-#         password="ircadircad",  # Replace with your password
-#         database="snipr_results"  # Replace with your database name
-#     )
-#
-
-# Database connection setup
-def connect_to_database():
-    # Pool of random IP addresses
-    ip_pool = [
-        "127.0.0.1",
-        "192.168.1.100",  # Replace with your database server IPs
-        "192.168.1.101",
-        "203.0.113.50",
-        "203.0.113.51"
-    ]
-
-    # Randomly select an IP address from the pool
-    random_ip = random.choice(ip_pool)
-
-    try:
-        # Establish connection
-        connection = mysql.connector.connect(
-            host='10.39.217.11', ###'128.252.210.4', ##'10.39.217.11', #random_ip,  # Use the randomly selected IP
-            user="root",  # Replace with your username
-            password="ircadircad",  # Replace with your password
-            database="snipr_results"  # Replace with your database name
-        )
-        print(f"Connected to database at {random_ip}")
-        return connection
-    except mysql.connector.Error as error:
-        print(f"Failed to connect to the database: {error}")
-        return None
-
-# Insert data into the table
-def insert_data(session_id, session_name, scan_id, scan_name):
-    try:
-        connection = connect_to_database()
-        cursor = connection.cursor()
-
-        # SQL query to insert data
-
-        sql_query = """
-            INSERT INTO results (session_id, session_name, scan_id, scan_name,session_id_scan_id)
-            VALUES (%s, %s, %s, %s,%s)
-        """
-
-        # Parameters for the query
-        data = (session_id, session_name, scan_id, scan_name,str(session_id)+"_"+str(scan_id))
-
-        # Execute and commit the transaction
-        cursor.execute(sql_query, data)
-        connection.commit()
-
-
-        print(f"Record inserted successfully. ID: {cursor.lastrowid}")
-
-    except mysql.connector.Error as error:
-        print(f"Failed to insert record into table: {error}")
-    finally:
-        if connection.is_connected():
-            cursor.close()
-            connection.close()
-            print("MySQL connection closed.")
-
-# Function to check if a column exists
-def column_exists(cursor, table_name, column_name):
-    cursor.execute(f"SHOW COLUMNS FROM {table_name} LIKE '{column_name}';")
-    return cursor.fetchone() is not None
-
-# Main function to update or create column
-def update_or_create_column(session_id, scan_id, column_name, column_value,session_name="SESSION_NAME",scan_name="SCAN_NAME"):
-    try:
-        connection = connect_to_database()
-        cursor = connection.cursor()
-
-        # Step 1: Generate session_id_scan_id value
-        session_id_scan_id = f"{session_id}_{scan_id}"
-        if not column_exists(cursor, "results", 'session_id_scan_id'):
-            insert_data(session_id, session_name, scan_id, scan_name)
-        # Add the new column if it doesn't exist
-        #     alter_query = f"ALTER TABLE results ADD COLUMN {column_name} VARCHAR(255);"
-        #     cursor.execute(alter_query)
-        #     connection.commit()
-        #     print(f"Column '{column_name}' added as VARCHAR(255).")
-        # Step 2: Check if the row exists based on session_id_scan_id
-        select_query = """
-            SELECT * FROM results
-            WHERE session_id_scan_id = %s;
-        """
-        cursor.execute(select_query, (session_id_scan_id,))
-        row = cursor.fetchone()  # Fetch one row to consume the result
-
-        if row is None:
-            print("No matching row found. Inserting new row...")
-            # Insert a new row if it doesn't exist
-            insert_query = """
-                INSERT INTO results (session_id_scan_id, session_id, scan_id)
-                VALUES (%s, %s, %s);
-            """
-            cursor.execute(insert_query, (session_id_scan_id, session_id, scan_id))
-            connection.commit()
-
-        # Step 3: Check if the new column exists
-        if not column_exists(cursor, "results", column_name):
-            # Add the new column if it doesn't exist
-            alter_query = f"ALTER TABLE results ADD COLUMN {column_name} VARCHAR(255);"
-            cursor.execute(alter_query)
-            connection.commit()
-            print(f"Column '{column_name}' added as VARCHAR(255).")
-
-        # Step 4: Update the new column with the provided value for the matching row
-        update_query = f"""
-            UPDATE results
-            SET {column_name} = %s
-            WHERE session_id_scan_id = %s;
-        """
-        cursor.execute(update_query, (column_value, session_id_scan_id))
-        connection.commit()
-
-        print(f"'{column_name}' updated to '{column_value}' for session_id='{session_id}' and scan_id='{scan_id}'.")
-
-    except mysql.connector.Error as error:
-        print(f"Failed to execute operation: {error}")
-    finally:
-        if connection.is_connected():
-            cursor.close()
-            connection.close()
-            print("MySQL connection closed.")
-
-# Example usage
-if __name__ == "__main__":
-    # Replace these with actual values
-    session_id = sys.argv[1] # "session_133"
-    session_name =sys.argv[2] #  "Session Name Example"
-    scan_id =sys.argv[3] #  "scan_456"
-    scan_name =sys.argv[4] #  "Scan Name Example"
-
-    # Insert initial data
-    insert_data(session_id, session_name, scan_id, scan_name)
-
-    # Update or create column
-    column_name =sys.argv[5] #  "volume"  # Specify the new column name
-    column_value =sys.argv[6] #  "200"  # Value to be set in the new column
-
-    update_or_create_column(session_id, scan_id, column_name, column_value,session_name,scan_name)
-    # update_or_create_column(session_id, scan_id, 'session_name', session_name,session_name,scan_name)
-    # update_or_create_column(session_id, scan_id, 'scan_name', scan_name,session_name,scan_name)
